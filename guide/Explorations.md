# Исследования

>[!IMPORTANT]
>Данный раздел будет сделан в виде ответов на популярные вопросы для более простого чтения.

### Есть ли смысл выключать службы? Насколько это помогает?

- Нет. Отключение служб не дает никакого преимущества.

#### Пояснение:

Службы используют ресурсы и вызывают события, как и обычные программы, но это не означает, что их потребление будет значительным.

Сравним потребление служб на чистой Windows 11 и с выключенными службами:

![servicesON](/docs/servicesON_ph.png)

![servicesOFF](/docs/ServicesOFF_ph.png)

Как можно заметить, разница в потреблении (Cycles Delta) минимальна. Чтобы понять разницу, можно посмотрть на потребление Process Explorer (proexp64.exe), который не является ресурсоёмкой программой.

Вывод: Проблемы от неправильного выключения служб изза их системы зависимостей, отказ от функций, которые привязаны к службам не стоят мизерного уменьшения потребления.

Дополнительная информация:

- Начиная с 23h2 (Май 2023 года) фоновые процессы были ограничены в фоновом потреблении за счет снижение частоты опроса ([1](https://blogs.windows.com/windowsdeveloper/2023/05/26/delivering-delightful-performance-for-more-than-one-billion-users-worldwide)), что еще больше уменьшает потребление служб.

- Данное правило применимо и к драйверам.

- MMCSS является исключением, он вызывает слишком большое количество событий изза постоянного использования.

- На скринах можно заметить, что службы после отключения потребляют меньше памяти. На самом деле потребление службы выгружаются в файл подкачки, когда в ОЗУ нехватает памяти для программ. Тоесть, потребление служб ещё больше переоценено. 

### Сколько дает отключение визуальных эффектов в Быстродействии?

- Ничего не дает.

#### Пояснение:

На изображениях, которые были представленны выше, вы можете увидеть потребление ```exprorer.exe``` с ```Обеспечить наилучшее быстродействие``` и стандартным набором.

Вывод: Отключение сглаживание экранных шрифтов и всего остального визуала ничего не дает.


### SystemResponsiveness - что это такое и нужно ли оно вообще?

- И да и нет. Если вы выключаете MMCSS, то смысла от данного ключа реестра нет.

#### Пояснение:

SystemResponsiveness указывает MMCSS, какой процесс, когда и на сколько он должен получить буст приоритета.

Если посмотреть на её работу на практике, она почти никак не влияет на время приоритета и на приоритет выставляемый MMCSS.

Вывод: Ключ реестра не дает какого-то преимущества в отзывчивости MMCSS. Если вы всё таки хотите минимизировать время отклика MMCSS, то поставьте ```0x10``` hex.


### Частота прерываний по системному таймеру (разрешение таймера)

Частота тактовых прерываний - это частота, с которой системный таймер системы генерируют прерывания, позволяющие планировщику выполнять различные задачи, например хронометраж. В большинстве систем по умолчанию минимальная частота составляет 64 Гц, что означает, что прерывание генерируется каждые 15,625 мс. Более низкая частота приводит к снижению нагрузки на процессор и энергопотребления за счет меньшего количества прерываний, но снижает точность синхронизации и приводит к потенциально менее отзывчивой многозадачности. Максимальная частота составляет 2 кГц, что означает, что прерывание генерируется каждые 0,5 мс. Более высокая частота обеспечивает более высокую точность синхронизации, потенциально более высокую скорость отклика многозадачной системы, но увеличивает нагрузку на процессор и энергопотребление. Минимальное, текущее и максимальное разрешение можно посмотреть в [ClockRes](https://learn.microsoft.com/en-us/sysinternals/downloads/clockres).

Приложения, которым требуется более высокая точность, чем стандартное разрешение 15,625 мс, могут повысить частоту прерывания часов с помощью таких функций, как [timeBeginPeriod](https://learn.microsoft.com/en-us/windows/win32/api/timeapi/nf-timeapi-timebeginperiod) и [NtSetTimerResolution](http://undocumented.ntinternals.net/index.html?page=UserMode%2FUndocumented%20Functions%2FTime%2FNtSetTimerResolution.html). В этих сценариях обычно используются воспроизведение мультимедиа, игры, VoIP-активность и многое другое, что можно увидеть, запустив трассировку энергопотребления ([инструкции](https://support.microsoft.com/en-gb/topic/guided-help-get-a-detailed-power-efficiency-diagnostics-report-for-your-computer-in-windows-7-3f6ce138-fc04-7648-089a-854bcf332810)) во время выполнения. Точность функций, которые полагаются на функции сна для отслеживания событий, напрямую зависит от частоты прерывания часов ([1](https://randomascii.wordpress.com/wp-content/uploads/2020/10/image-5.png)). Если использовать [Sleep](https://learn.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-sleep) в качестве примера, то ``Sleep(n)`` должна спать в течение n миллисекунд на самом деле, а не n плюс/минус произвольное значение, иначе это может привести к неожиданному и непостоянному темпу событий, что не является идеальным для таких функций, как ограничители частоты кадров на основе сна. Обратите внимание, что это пример, и многие реальные приложения не полагаются конкретно на функцию ``Sleep`` для отслеживания событий. Типичным значением, до которого разработчики обычно поднимают разрешение, является 1 мс, что означает, что приложение может поддерживать темп событий в пределах разрешения 1 мс. В очень редких случаях разработчики могут вообще не повышать разрешение, в то время как их приложение полагается на него для точности темпа событий, что приводит к поломке, но это не так часто встречается и может быть применимо к некоторым малоизвестным программам, таким как малоизвестные игры.

Реализация разрешения таймера изменилась в Windows 10 2004+ таким образом, что вызывающий процесс, повышающий разрешение, не влияет на систему на глобальном уровне, то есть процесс A, повышающий разрешение до 1 мс, не влияет на процесс B с разрешением по умолчанию 15,625 мс, как раньше. Это само по себе отличное изменение, поскольку оно снижает накладные расходы, так как другие процессы, такие как неработающие фоновые процессы, не обслуживаются планировщиком часто, а вызывающий процесс получает более высокую точность по мере необходимости. Однако для конечного пользователя это приводит к ограничениям при желании использовать более высокие разрешения, например 0,5 мс.  Учитывая, что игры не имеют открытого исходного кода для его модификации, а также ограничения античита, препятствующие внедрению DLL или исправлению бинарных файлов для повышения разрешения выше 1 мс в рамках каждого процесса, единственным вариантом является использование глобального поведения, которое применимо с ключом реестра, указанным ниже, в Windows Server 2022 и Windows 11+, как подробно объясняется [здесь](https://github.com/valleyofdoom/PC-Tuning/blob/main/docs/research.md#6-fixing-timing-precision-in-windows-after-the-great-rule-change).

```
[HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\kernel]
"GlobalTimerResolutionRequests"=dword:00000001
```
Это дает возможность повышать разрешение в отдельном процессе, что, в свою очередь, приводит к тому, что нужное приложение, например игра, получает более высокую точность. **Однако, как уже говорилось ранее, имплантация в каждый процесс снижает накладные расходы, чего уже не происходит при восстановлении глобального поведения, а фоновые процессы также обслуживаются неоправданно часто.** [RTSS](https://www.guru3d.com/download/rtss-rivatuner-statistics-server-download) является альтернативным методом ограничения частоты кадров и использует гибридное ожидание, которое обеспечивает более высокую точность, устраняя необходимость в восстановлении глобального поведения.

Более высокое разрешение обеспечивает более высокую точность, но в некоторых случаях максимальное поддерживаемое разрешение 0,5 мс обеспечивает меньшую точность, чем несколько меньшее, например 0,507 мс ([1](https://github.com/valleyofdoom/PC-Tuning/blob/main/docs/research.md#7-micro-adjusting-timer-resolution-for-higher-precision)). Поэтому имеет смысл определить, какое разрешение вызова обеспечивает наибольшую точность (наименьшие дельты) в программе [MeasureSleep](https://github.com/valleyofdoom/TimerResolution), а также запросить различные разрешения в программе [SetTimerResolution](https://github.com/valleyofdoom/TimerResolution). Это следует делать под нагрузкой, так как холостые бенчмарки могут вводить в заблуждение. Для автоматизации процесса можно использовать скрипт [micro-adjust-benchmark.ps1](https://github.com/valleyofdoom/TimerResolution).

В заключение своего мнения по этому вопросу **я рекомендую отдать предпочтение реализации per-process (неглобальной)**, где это применимо, так как это снижает накладные расходы, и вместо этого использовать [RTSS](https://www.guru3d.com/download/rtss-rivatuner-statistics-server-download) для точного ограничения частоты кадров.
Стоит отметить, что она может вносить заметно большую задержку ([1](https://www.youtube.com/watch?t=377&v=T2ENf9cigSk), [2](https://en.wikipedia.org/wiki/Busy_waiting)), поэтому я рекомендую сравнивать и тестировать ее с микрорегулировкой запрашиваемого разрешения для большей точности при глобальном поведении. Возможно, на стабильность фреймрейта не влияет повышение разрешения выше 1 мс из-за улучшений внутриигрового ограничителя фреймрейта, и в этом случае никаких действий предпринимать не нужно. **Главное, что я хочу донести до вас, - это сравнить все доступные варианты, отдав предпочтение поведению для каждого процесса, которое используется по умолчанию в Windows 10 2004+, если вы обнаружите, что дальнейшее повышение разрешения практически не влияет на ситуацию.**

### Сериализация окончания таймера (SerializeTimerExpiration)

**EXO** : На W11 24h2 ``SerializeTimerExpiration`` работает так:

``SerializeTimerExpiration``=``1`` (При условии что приложение вызывает 0,5 ms):

- Интервал между прерываниями системного таймера на **ядре 0** равен 0,495-0,500 ms, а интервал между прерываниями системного таймера на **остальных ядрах** равен 1,7 ms

``SerializeTimerExpiration``=``2`` (При условии что приложение вызывает 0,5 ms):

- Интервал между прерываниями системного таймера на всех ядрах равен 0,495-0,500 ms

``SerializeTimerExpiration``=``0``:

- Выбирает автоматически исходя из того доступен ли ``MODERN STANDBY`` (В основном это будет равноценно значению ``1``, если он доступен)


В итоге когда вы ставите значение ``2``, то вы лишь добавляете нагрузку на все ядра вместо одного **(ядро 0)** ради минимального улучшения точности системного таймера, так как судя по всему прерывания системного таймера со всех ядер будут обновлять системное время/часы, а не только прерывания с **ядра 0**, то есть асинхронно.

```
[HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\kernel]
"SerializeTimerExpiration"=dword:00000000
```

### О Tickless kernel (Bcd store параметры) 

- ``UsePlatformTick`` - Microsoft: *Заставляет часы опираться на платформный таймер, синтетические таймеры не допускаются. Опция доступна начиная с Windows 8 и Windows Server 2012* ([1](https://learn.microsoft.com/en-us/windows-hardware/drivers/devtest/bcdedit--set)).

    - Отключает тик-систему TSC и использует вместо него тик источника платформы (RTC)

        - ``useplatformtick`` заставит использовать RTC, который является устаревшой системой тикрейта. Не являясь динамическим тиком и не имея интеллектуальных оптимизаций вычислений, он фактически снизит производительность вашей системы.

        - Форсирует использование таймера в *0.5 ms* и *1.0 ms* 

- ``disabledynamictick`` - Microsoft: *Включает и выключает функцию динамического тика таймера* ([1](https://learn.microsoft.com/en-us/windows-hardware/drivers/devtest/bcdedit--set)).

    - Для большей информации прочитайте [это](https://en.wikipedia.org/wiki/Tickless_kernel#cite_note-ars-technica-win8-1) и [это](https://arstechnica.com/information-technology/2012/10/better-on-the-inside-under-the-hood-of-windows-8/2/) 

        - Когда динамический таймер включен: Функция, вызывающая слияние тиков таймера, когда находится в режиме ожидания.

        - Отключения динамического таймера ничего не даст, потому что начиная с Windows 10 таймер почти не уходит в простой ([1](/docs/idle_by_timer_duration.png)).
     
        - На 11 Windows изза того, что приложения больше не зависят от одного таймера, отключение становится еще более нецелесообразным.
